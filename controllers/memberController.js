import { getTenantModels } from '../utils/tenantModels.js';
import { generateMemberId } from '../utils/memberIdGenerator.js';
import { getTenantModel } from '../models/Tenant.js';
import { parseBulkMembersExcel, generateBulkMembersTemplate } from '../utils/excelExporter.js';

const MAX_BULK_FILE_SIZE = 2 * 1024 * 1024; // 2 MB

export const getBulkMembersTemplate = async (req, res) => {
  try {
    const buffer = await generateBulkMembersTemplate();
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    res.setHeader('Content-Disposition', 'attachment; filename=members-bulk-template.xlsx');
    res.send(buffer);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

export const getAllMembers = async (req, res) => {
  try {
    const { Member } = getTenantModels(req);
    const { search, role } = req.query;
    let query = {};

    if (search) {
      query = {
        $or: [
          { name: { $regex: search, $options: 'i' } },
          { memberId: { $regex: search, $options: 'i' } },
          { contact: { $regex: search, $options: 'i' } },
          { email: { $regex: search, $options: 'i' } }
        ]
      };
    }

    if (role) {
      query.role = role;
    }

    const members = await Member.find(query)
      .populate('subgroupId', 'name')
      .sort({ createdAt: -1 });
    
    // Calculate arrears for each member
    const membersWithArrears = members.map(member => {
      const arrears = member.calculateArrears();
      member.arrears = arrears;
      return member;
    });

    res.json(membersWithArrears);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

export const getMemberById = async (req, res) => {
  try {
    const { Member } = getTenantModels(req);
    const member = await Member.findById(req.params.id).populate('subgroupId', 'name');
    if (!member) {
      return res.status(404).json({ error: 'Member not found' });
    }

    member.arrears = member.calculateArrears();
    res.json(member);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

export const createMember = async (req, res) => {
  try {
    const { Member, Subgroup, ActivityLog } = getTenantModels(req);
    const {
      name,
      memberId,
      contact,
      email,
      joinDate,
      duesPerMonth,
      subgroupId,
      role,
      autoGenerateId
    } = req.body;

    if (!name || !duesPerMonth || !email) {
      return res
        .status(400)
        .json({ error: 'Name, email, and dues per month are required' });
    }

    // Validation: If autoGenerateId is true, memberId should not be provided
    if (autoGenerateId === true && memberId) {
      return res.status(400).json({ 
        error: 'Cannot provide memberId when autoGenerateId is enabled' 
      });
    }

    const normalizedEmail = email.toLowerCase();

    let resolvedSubgroupId = null;
    if (subgroupId) {
      const subgroup = await Subgroup.findById(subgroupId);
      if (!subgroup) {
        return res.status(400).json({ error: 'Invalid subgroup selected' });
      }
      resolvedSubgroupId = subgroupId;
    }

    // Handle auto-generated member ID
    let finalMemberId = memberId;
    let isAutoGenerated = false;

    if (autoGenerateId === true) {
      // Get tenant information
      if (!req.tenant) {
        return res.status(400).json({ error: 'Tenant context is required for auto-generating member ID' });
      }

      const Tenant = await getTenantModel();
      const tenant = await Tenant.findById(req.tenant._id);
      
      if (!tenant) {
        return res.status(404).json({ error: 'Tenant not found' });
      }

      // Generate member ID
      finalMemberId = generateMemberId(tenant.name, tenant.memberIdCounter || 0);
      
      // Increment tenant counter
      tenant.memberIdCounter = (tenant.memberIdCounter || 0) + 1;
      await tenant.save();
      
      isAutoGenerated = true;
    }

    const member = await Member.create({
      name,
      memberId: finalMemberId,
      isAutoGeneratedId: isAutoGenerated,
      contact,
      email: normalizedEmail,
      joinDate: joinDate ? new Date(joinDate) : new Date(),
      duesPerMonth: parseFloat(duesPerMonth),
      totalPaid: 0,
      monthsCovered: 0,
      arrears: 0,
      subgroupId: resolvedSubgroupId,
      role: role && ['member', 'admin'].includes(role) ? role : 'member'
    });

    // Log activity (only for admin users)
    if (req.user.role === 'admin') {
      const log = new ActivityLog({
        actor: req.user.username,
        role: req.user.role,
        action: `Created member: ${name}`,
        affectedMember: member._id.toString()
      });
      await log.save();
    }

    res.status(201).json(member);
  } catch (error) {
    if (error.code === 11000) {
      return res.status(400).json({ error: 'Member ID already exists' });
    }
    res.status(500).json({ error: error.message });
  }
};

export const updateMember = async (req, res) => {
  try {
    const { Member, Subgroup, ActivityLog } = getTenantModels(req);
    const {
      name,
      memberId,
      contact,
      email,
      joinDate,
      duesPerMonth,
      subgroupId,
      role,
      autoGenerateId,
      isAutoGeneratedId
    } = req.body;
    const member = await Member.findById(req.params.id);

    if (!member) {
      return res.status(404).json({ error: 'Member not found' });
    }

    // Prevent changing isAutoGeneratedId field
    if (isAutoGeneratedId !== undefined || autoGenerateId !== undefined) {
      return res.status(400).json({ 
        error: 'Cannot change auto-generation status of member ID' 
      });
    }

    // If member has auto-generated ID, prevent changing it
    if (member.isAutoGeneratedId && memberId !== undefined && memberId !== member.memberId) {
      return res.status(400).json({ 
        error: 'Cannot modify auto-generated member ID' 
      });
    }

    if (name) member.name = name;
    if (memberId !== undefined && !member.isAutoGeneratedId) {
      member.memberId = memberId;
    }
    if (contact !== undefined) member.contact = contact;
    if (email !== undefined) {
      member.email = email ? email.toLowerCase() : null;
    }
    if (joinDate) member.joinDate = new Date(joinDate);
    if (duesPerMonth) member.duesPerMonth = parseFloat(duesPerMonth);
    if (role && ['member', 'admin'].includes(role)) {
      member.role = role;
    }

    if (subgroupId !== undefined) {
      if (subgroupId) {
        const subgroup = await Subgroup.findById(subgroupId);
        if (!subgroup) {
          return res.status(400).json({ error: 'Invalid subgroup selected' });
        }
        member.subgroupId = subgroupId;
      } else {
        member.subgroupId = null;
      }
    }

    await member.save();

    // Log activity (only for admin users)
    if (req.user.role === 'admin') {
      const log = new ActivityLog({
        actor: req.user.username,
        role: req.user.role,
        action: `Updated member: ${member.name}`,
        affectedMember: member._id.toString()
      });
      await log.save();
    }

    res.json(member);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

export const deleteMember = async (req, res) => {
  try {
    const { Member, ActivityLog } = getTenantModels(req);
    const member = await Member.findById(req.params.id);
    if (!member) {
      return res.status(404).json({ error: 'Member not found' });
    }

    const memberName = member.name;
    await Member.findByIdAndDelete(req.params.id);

    // Log activity (only for admin users)
    if (req.user.role === 'admin') {
      const log = new ActivityLog({
        actor: req.user.username,
        role: req.user.role,
        action: `Deleted member: ${memberName}`,
        affectedMember: req.params.id
      });
      await log.save();
    }

    res.json({ message: 'Member deleted successfully' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

/**
 * Bulk create members from an array of { name, email?, contact?, subgroup? } or from Excel (body.file base64).
 * subgroup = subgroup name (matched case-insensitively); optional. All get auto-generated member IDs and the same duesPerMonth and join date (today).
 */
export const createBulkMembers = async (req, res) => {
  try {
    const { Member, Subgroup, ActivityLog } = getTenantModels(req);
    let rawMembers = req.body.members;
    let duesPerMonth = req.body.duesPerMonth;

    if (req.body.file) {
      const fileName = (req.body.fileName || '').toLowerCase();
      if (!fileName.endsWith('.xlsx')) {
        return res.status(400).json({ error: 'Only .xlsx files are allowed' });
      }
      let buffer;
      try {
        buffer = Buffer.from(req.body.file, 'base64');
      } catch (e) {
        return res.status(400).json({ error: 'Invalid file encoding' });
      }
      if (buffer.length > MAX_BULK_FILE_SIZE) {
        return res.status(400).json({ error: `File too large. Maximum size is ${MAX_BULK_FILE_SIZE / 1024 / 1024} MB` });
      }
      let parsed;
      try {
        parsed = await parseBulkMembersExcel(buffer);
      } catch (e) {
        return res.status(400).json({ error: 'Invalid or corrupted Excel file' });
      }
      if (parsed.errors && parsed.errors.length > 0) {
        return res.status(400).json({ error: parsed.errors[0].message, details: parsed.errors });
      }
      rawMembers = parsed.members;
    }

    if (!Array.isArray(rawMembers) || rawMembers.length === 0) {
      return res.status(400).json({ error: 'members must be a non-empty array (or upload an Excel file with at least one data row)' });
    }
    const dues = parseFloat(duesPerMonth);
    if (isNaN(dues) || dues < 0) {
      return res.status(400).json({ error: 'duesPerMonth is required and must be a number >= 0' });
    }

    if (!req.tenant) {
      return res.status(400).json({ error: 'Tenant context is required' });
    }
    const Tenant = await getTenantModel();
    const tenant = await Tenant.findById(req.tenant._id || req.tenant.id);
    if (!tenant) {
      return res.status(404).json({ error: 'Tenant not found' });
    }

    const joinDate = new Date();
    const created = [];
    const errors = [];
    let subgroupCache = null;

    const resolveSubgroup = async (subgroupNameOrId) => {
      const str = (subgroupNameOrId || '').trim();
      if (!str) return null;
      if (!subgroupCache) {
        const list = await Subgroup.find({});
        subgroupCache = list;
      }
      const byId = subgroupCache.find((s) => (s._id && s._id.toString() === str) || (s.id && s.id === str));
      if (byId) return byId._id || byId.id;
      const byName = subgroupCache.find((s) => (s.name || '').toLowerCase() === str.toLowerCase());
      return byName ? (byName._id || byName.id) : null;
    };

    for (let i = 0; i < rawMembers.length; i++) {
      const row = rawMembers[i];
      const name = (row.name || '').trim();
      const email = (row.email || '').trim().toLowerCase();
      const contact = (row.contact || row.phone || '').trim();
      const subgroupNameOrId = (row.subgroup || row.group || '').trim();

      if (!name) {
        errors.push({ row: i + 1, message: 'Name is required' });
        continue;
      }

      try {
        const resolvedSubgroupId = await resolveSubgroup(subgroupNameOrId);

        const finalMemberId = generateMemberId(tenant.name, tenant.memberIdCounter || 0);
        tenant.memberIdCounter = (tenant.memberIdCounter || 0) + 1;
        await tenant.save();

        const member = await Member.create({
          name,
          memberId: finalMemberId,
          isAutoGeneratedId: true,
          contact: contact || undefined,
          email: email || undefined,
          joinDate,
          duesPerMonth: dues,
          totalPaid: 0,
          monthsCovered: 0,
          arrears: 0,
          subgroupId: resolvedSubgroupId || null,
          role: 'member'
        });

        if (req.user.role === 'admin') {
          const log = new ActivityLog({
            actor: req.user.username,
            role: req.user.role,
            action: `Created member (bulk): ${name}`,
            affectedMember: member._id?.toString?.() || member.id
          });
          await log.save();
        }

        created.push({ name: member.name, memberId: member.memberId, id: member._id || member.id });
      } catch (err) {
        errors.push({ row: i + 1, name, message: err.message || 'Failed to create' });
      }
    }

    res.status(201).json({
      message: `Created ${created.length} member(s)`,
      created,
      errors: errors.length ? errors : undefined
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

export const getMembersInArrears = async (req, res) => {
  try {
    const { Member } = getTenantModels(req);
    const members = await Member.find().populate('subgroupId', 'name');
    const membersInArrears = members
      .map(member => {
        member.arrears = member.calculateArrears();
        return member;
      })
      .filter(member => member.arrears > 0)
      .sort((a, b) => b.arrears - a.arrears);

    res.json(membersInArrears);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

